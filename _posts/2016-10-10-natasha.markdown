---
layout: post
title: Tuning Recurrent Neural Networks with Reinforcement Learning
date:   2016-10-24 08:00:00 -0700
author: natashajaques
tags: magenta,melody,rnn,lstm,reinforcement,music
excerpt_separator: <!--more-->
---

When I joined [Magenta][magenta] as an intern this summer, the team was hard at work on developing better ways to train Recurrent Neural Networks (RNNs) to generate sequences of notes. As you may remember from [previous posts][elliot post], these models typically consist of a Long Short-Term Memory (LSTM) network trained on monophonic melodies. This means that melodies are fed into the network one note at a time, and it is trained to predict the next note in the sequence. The figure below shows a simplified version of this type of network unrolled over time, in which it is being trained on the first 6 notes of "Twinkle Twinkle Little Star". From now on, I'll refer to this type of model as a **Note RNN**.

<div style="text-align:center"><img src="/assets/rl_rnn/note_rnn_model.png" width="256"></div>

<!--With a little hard work and creativity, a *Note RNN* can produce [nice melodies][elliot song].--> A *Note RNN* is conceptually similar to a *Character RNN*, a popular model for generating text, one character at a time. While both types of models can produce impressive results, they have some frustrating limitations. They both suffer from common failure modes, such as continually repeating the same token. Further, the sequences produced by the models tend to lack a consistent global structure. To see this more clearly, take a look at the text below, which was generated by a Character RNN trained on Wikipedia markdown data (taken from [Graves, 2013][graves]):

>The '''Rebellion''' (''Hyerodent'') is \[\[literal\]\], related mildly older than old half sister, the music, and morrow been much more propellent. All those of \[\[Hamas (mass)&#124;sausage trafficking\]\]s were also known as \[\[Trip class submarine&#124;"Sante" at Serassim\]\]; "Verra" as 1865-682-831 is related to ballistic missiles. While she viewed it friend of Halla equatorial weapons of Tuscany, in [[France]], from vaccine homes to &quot;individual&quot;, among \[\[slavery&#124;slaves\]\](such as artistual selling of factories were renamed English habit of twelve years.) 

While the model has learned how to correctly spell English words, some markdown syntax, and even mostly correct grammatical structure, sentences don't seem to follow a consistent thought. The text wonders rapidly from topic to topic, discussing everything from sisters to submarines to Tuscany, slavery, and factories, all in one short paragraph. This type of global incoherence is typical of the melodies produced by a vanilla *Note RNN* as well. They do not maintain a consistent musical structure, and can sound wandering and random. 

Music is an interesting test-bed for sequence generation, in that musical compositions adhere to a relatively well-defined set of structural rules. Any beginning music student learns that groups of notes belong to keys, chords follow progressions, and songs have consistent structures made up of musical phrases. So what if we could teach a *Note RNN* these kinds of musical rules, while still allowing it to learn patterns from music it hears in the world? 

This is the idea behind the **RL Tuner** model I will describe in this post. We take a trained *Note RNN* and teach it concepts of music theory using Reinforcement Learning (RL). RL can allow a network to learn some non-differentiable *reward* function. In this case, we define a set of music theory rules, and produce rewards based on whether the model's compositions adhere to those rules. However, to ensure that the model can remember the note probabilities it originally learned from data, we keep a second, fixed copy of the *Note RNN* which we call the *Reward RNN*. The *Reward RNN* is used to compute the probability of playing the next note as learned by the original *Note RNN*. We augment our music theory rewards with this probability value, so that the total reward reflects both our music theory constraints and information learned from data.

We show that this approach allows the model to maintain information about the note probabilities learned from data, while significantly improving the behaviors of the *Note RNN* targeted by the music theory rewards. For example, before training with RL, 63.3% of notes produced by the *Note RNN* belonged to some excessively repeated segment of notes; after RL, 0.0-0.03% of notes were excessively repeated. Since excessively repeating tokens is a problem in other domains as well (e.g. text generation), we believe our approach could have broader applications. But does it actually work to produce better music? We conducted a user study and found that people find the compositions produced by our three RL models significantly more musically pleasing than those of the original *Note RNN*. But we encourage you to judge for yourself; samples from each of the models will be provided later in this post.

The models, derivations, and results are all described in our recent [research paper][our arxiv], written by myself, Shane Gu, Richard E. Turner, and Douglas Eck<sup>[1](#footnote-nipsrl)</sup>. [Code][code] to run this model is also available on the Magenta github repo; please try it out! The music theory rules implemented for the model are only a first attempt, and could easily be improved by someone with musical training.

<a name="footnote-nipsrl"><sub><sup>1</sup></sub></a> <sub><sup>A version of this work was accepted at the [NIPS 2016 Deep Reinforcement Learning Workshop][nips rl].</sup></sub> 

Introduction to Reinforcement Learning and Deep Q-Learning
----------------------------------------------------------
*This section will give a brief introduction to some ideas behind RL and Deep Q Networks (DQNs). Those of you familiar with these topics may wish to skip ahead.*

In reinforcement learning (RL), an agent interacts with an environment. Given the state of the enviornment $$s$$, the agent takes an action $$a$$, receives a reward $$r$$, and the environment transitions to a new state, $$s'$$. The goal of the agent is to maximize reward, which is usually some clear signal from the environment, such as points in a game. 

The rules for how the agent chooses to act in the environment define a *policy*. To learn the most effective policy, the agent can't just greedily maximize the reward it will receive after the next action, but must instead consider the total cumulative reward it can expect to receive over a course of actions occurring in the future. Because future rewards are typically uncertain if the environment has random effects, a discount factor of $$\gamma$$ is applied to the reward for each timestep in the future. If $$r_t$$ is the reward received at timestep $$t$$, then $$R_t$$ is the total future discounted *return*:
\begin{align}
R_t = \sum^T_{t'=t}\gamma^{t'-t}r_{t'} 
\end{align}

In Q-learning, the goal is to learn a Q function that gives the maximum expected discounted future return for taking any action $$a$$ in state $$s$$, and continuing to act optimally at each step in the future. Therefore the optimal Q function, $$Q^*$$ is defined as:

$$\begin{align}
Q^*(s, a) = max_\pi \mathbb{E}[R_t|s_t = s, a_t = a, \pi]
\end{align}$$

where $$\pi$$ is a policy mapping states to distributions over actions. To learn $$Q*$$, we can apply an iterative update based on the Bellman equation:
\begin{align}
Q_{i+1}(s, a) = \mathbb{E}[r + \gamma max_{a'}Q_i(s',a')|s,a]
\end{align}
where *r* is the reward received for taking action *a* in state *s*. This value iteration method will converge to $$Q^*$$ as $$i \rightarrow \infty$$.

In [Deep Q Learning][dqn], a neural network called the Deep Q-network (DQN) is used to approximate the Q function, $$Q(s, a; \theta) \approx Q^*(s, a)$$. The network parameters $$\theta$$ are learned by applying stochastic gradient descent (SGD) updates with respect to the following loss function:
\begin{align} 
\label{eq:qloss}
L_t(\theta_t) = (r_t + \gamma \max_{a'}Q(s',a';\theta_{t-1}) - Q(s,a;\theta_t))^2
\end{align}
The loss function describes the difference between the actual reward received at step $$t$$ ($$r_t$$) plus the discounted future return estimated by the *Q-network* parameters at step $$t-1$$, and the expected future discounted return output by the *Q-network* at step $$t$$. Essentially, this is the prediction error in estimating the $$Q$$ function made by the *Q-network*. Importantly, the parameters for the previous generation of the network ($$\theta_{t-1}$$) are held fixed, and not updated by SGD.

<!--While interacting with the environment, the $$Q$$-learning agent typically follows an $$\epsilon$$-greedy policy. This means that it will greedily choose the action with the highest Q value with probability $$1-\epsilon$$, and choose a random action with probability $$\epsilon$$. This off-policy learning method ensures a reasonably trade-off between exploration of the action space, and exploitation of the most efficient strategies learned so far. -->

Several techniques are required for a DQN to work effectively. As the agent interacts with the environment, $$<s_t,a_t,r_t,s_{t+1}>$$ tuples it experiences are stored in an *experience buffer*. Training the *Q-network* is accomplished by randomly sampling batches from the *experience buffer* to compute the loss. The *experience buffer* is essential for learning; if the agent was trained using consecutive samples of experience (as in online Q-learning), the samples would be highly correlated, updates would have high variance, and the network parameters could become stuck in a local minimum or diverge. 

Further optimizations to the DQN algorithm have been proposed that help enhance learning and ensure stability. One of these is [Deep Double Q-learning][dqqn], in which a second, *Target Q-network* is used to estimate expected future return, while the *Q-network* is used to choose the next action. Since Q-learning has been shown to learn unrealistically high action values because it estimates maximum expected return, having a second Q-network can lead to more realistic estimates and better performance.

RL Tuner
----------
As described above, the main idea behind the RL Tuner model is to take an RNN trained on data, and refine it using RL. The model uses a standard DQN implementation, complete with an *experience buffer* and *Target Q-network*. A trained *Note RNN* is used to supply the initial values of the weights in the *Q-network* and *Target Q-network*, and a third copy is  used as the *Reward RNN*. The *Reward RNN* is held fixed during training, and is used to supply part of the reward function used to train the model. The figure below illustrates these ideas. 

![Model diagram](/assets/rl_rnn/rl_rnn_diagram.png "Model diagram")

To formulate musical composition as an RL problem, we treat choosing the next note as taking an action $$a$$. The state of the environment $$s$$ consists of the state of the composition so far, as well as the internal LSTM state of the *Q-network* and *Reward RNN*. The reward function is a combination of both music theory rules and probabilities learned from data. The music theory reward $$r_{MT}(a,s)$$ is calculated by a set of functions described in the next section, that constrain the model to adhere to certain rules, such as playing in the same key. However, it is necessary that the model still be ``creative,'' rather than learning a simple composition that can easily exploit these rewards. Therefore, the *Reward RNN* is used to compute $$p(a$$&#124;$$s)$$, the probability of playing the next note $$a$$ given the composition $$s$$ as originally learned from data. The total reward given at time $$t$$ is therefore: 

$$\begin{align} 
\label{eq:reward}
r_t(a,s) = \log p(a|s) + \frac{1}{c}r_{MT}(a,s)
\end{align}$$

where $$c$$ is a constant controlling the emphasis placed on the music theory reward. So now, we see that the new loss function for our model is:

$$\begin{align}
\label{eq:melody_dqn_loss}
L_t(\theta_t) = (\log p(a|s) + \frac{1}{c}r_{MT}(a,s) + \gamma \max_{a'}Q(s',a';\theta_{t-1}) - Q(s,a;\theta_t))^2
\end{align}$$

This modified loss function forces the model to learn that the most valuable actions are those that conform to the music theory rules, but still have the high probability in the original data.

### For the mathematically inclined...

In [our paper][our arxiv] we show that the loss function described above can be related to Stochastic Optimal Control, which defines an RL problem in which KL-divergence from a prior policy is penalized. If we think of the probabilities learned by the *Note RNN* as the prior policy, and $$\pi_{\theta}$$ as the policy learned by the model, then this would be equivalent to learning the following function: 

$$\begin{align} 
L_v(\theta) &= \mathbb{E}_{\pi}[\sum_t r(s_t,a_t)/c - KL[\pi_\theta(\cdot|s_t)||p(\cdot|s_t)]]
\end{align}$$

This is not exactly the same as our method, because we are missing the entropy term in the KL-divergence function. This led us to implement two other KL-regularized variants of Q-learning: [$$\Psi$$ learning][psi learning], and [G learning][g learning]. The loss function for $$\Psi$$ learning is:

$$\begin{align} 
&L(\theta)= \mathbb{E}[(\log p(a|s) + \frac{1}{c}r_{MT}(s,a) + \gamma \log \sum_{a'} e^{\Psi(s',a';\theta^-)} - \Psi(s,a;\theta))^2]
\end{align}$$

And the loss function for G learning is:

$$\begin{align} 
&L(\theta)= \mathbb{E}_\beta[(\frac{1}{c}r_{MT}(s,a)+ \gamma \log \sum_{a'} e^{\log p(a'|s')+G(s',a';\theta^-)} - G(s,a;\theta))^2]
\end{align}$$

Music Theory Rewards
--------------------
The rules we implemented to make sure our model conformed to music theory were based on some domain knowledge, and the book ["A Practical Approach to Eighteenth-Century Counterpoint" by Robert Gauldin][gauldin]. We are by no means claiming that these rules are necessary for good compositions, exhaustive, or even particularly creative. They simply allow us to constrain our model to adhere to some sort of consistent structure. We encourage any interested readers to experiment with different rules and see what types of results they can produce. For now, the rules that we chose encourage the compositions produced by our model to have the following characteristics:

* **Stay in key**: Notes should belong to the same key. For example, if the desired key is C-major, a B-flat would not be an acceptable note. 

* **Begin and end with the tonic note**: The first note of the composition, and the first note of the final bar should be the tonic note of the key; e.g. if the key is C-major, this note would be middle C. 

* **Avoid excessively repeated notes**: Unless a rest is introduced or a note is held, a single tone should not be repeated more than four times in a row. While the number four can be considered a rough heuristic, avoiding excessively repeated notes and static melodic contours is [Gauldin's][gauldin] first rule of melodic composition.

* **Prefer harmonious intervals**: The composition should avoid awkward intervals like augmented sevenths, or large jumps of more than an octave. Gauldin also indicates good compositions should move by a mixture of small steps and larger harmonic intervals, with emphasis on the former; the reward values for intervals reflect these requirements.

*  **Resolve large leaps**: When the composition leaps several pitches in one direction, it should eventually be resolved by a leap back or gradual movement in the opposite direction. Leaping twice in the same direction is negatively rewarded. 

*  **Avoid continuously repeating extrema notes**: The highest note of the composition should be unique, as should the lowest note. 

*  **Avoid high auto-correlation**: To encourage variety, the reward function penalizes a melody if it is highly correlated with itself at a lag of 1, 2, or 3 beats. 

*  **Play motifs**: A musical motif is a succession of notes representing the shortest musical "idea"; in our implementation, it is defined as a bar of music with three or more unique notes. 

*  **Play repeated motifs**: Because [repetition has been shown to be key to emotional engagement with music][livingstone], we tried to train the model to repeat motifs that it had previously introduced. 


Results
----------

<table style="width:100%">
	<thead style="border-bottom:1px">
		<tr>
			<th style="text-align:left"> Behavior   </th>
			<th style="text-align:left"> Note RNN </th>
			<th style="text-align:left"> Q   </th>
			<th style="text-align:left"> Psi </th>
			<th style="text-align:left"> G </th>
		</tr>
	</thead>
	<tr>
		<td colspan="5" style="border-bottom:1px solid black;"></td>
	</tr>
	<tr>
		<td> Notes excessively repeated   </td>
		<td> 63.3% </td>
		<td> <strong>0.0%</strong> </td>
		<td> <strong>0.02%</strong> </td>
		<td> <strong>0.03%</strong> </td>
	</tr>
	<tr>
		<td> Notes not in key   </td>
		<td> 0.1% </td>
		<td> 1.0% </td>
		<td> 0.6% </td>
		<td> 28.7% </td>
	</tr>
	<tr>
		<td> Mean autocorrelation (lag 1,2,3)   </td>
		<td> -.16, .14, -.13 </td>
		<td> <strong>-.11, .03, .03</strong> </td>
		<td> <strong>-.10, -.01, .01</strong> </td>
		<td> .55, .31, .17 </td>
	</tr>
	<tr>
		<td colspan="5" style="border-bottom:1px solid black;"></td>
	</tr>
	<tr>
		<td> Leaps resolved   </td>
		<td> 77.2% </td>
		<td> <strong>91.1%</strong> </td>
		<td> <strong>90.0%</strong> </td>
		<td> 52.2% </td>
	</tr>
	<tr>
		<td> Leaps resolved   </td>
		<td> 77.2% </td>
		<td> <strong>91.1%</strong> </td>
		<td> <strong>90.0%</strong> </td>
		<td> 52.2% </td>
	</tr>
	<tr>
		<td> Notes not in key   </td>
		<td> 0.1% </td>
		<td> 1.0% </td>
		<td> 0.6% </td>
		<td> 28.7% </td>
	</tr>
	<tr>
		<td> Notes excessively repeated   </td>
		<td> 63.3% </td>
		<td> <strong>0.0%</strong> </td>
		<td> <strong>0.02%</strong> </td>
		<td> <strong>0.03%</strong> </td>
	</tr>
	<tr>
		<td> Notes excessively repeated   </td>
		<td> 63.3% </td>
		<td> <strong>0.0%</strong> </td>
		<td> <strong>0.02%</strong> </td>
		<td> <strong>0.03%</strong> </td>
	</tr>
</table>


<table>
	<thead style="border-bottom:1px">
		<tr style="border-bottom:1px solid black;">
			<th> Undesirable behavior   </th>
			<th> Note RNN </th>			
			<th> Q   </th>
			<th> $$\Psi$$ </th>
			<th> G </th>
		</tr>
	</thead>
	<tr>
		<td> Notes excessively repeated   </td>
		<td> 63.3% </td>
		<td> **0.0%** </td>
		<td> **0.02%** </td>
		<td> **0.03%** </td>
	</tr>
</table>

| Undesirable behavior              | Note RNN | Q         | $$\Psi$$  | G         |
|-----------------------------------|----------|-----------|-----------|-----------|
| Notes excessively repeated        | 63.3%    | **0.0%**  | **0.02%** | **0.03%** |
| Notes not in key                  | 0.1%     | 1.0%      | 0.6%      | 28.7%     |
| Mean autocorrelation - lag 1      | -.16     | **-.11**  | **-.10**  | .55       |
| Mean autocorrelation - lag 2      | .14      | **.03**   | **-.01**  | .31       |
| Mean autocorrelation - lag 3      | -.13     | **.03**   | **.01**   | .17        |

| Desirable behavior                | Note RNN | Q         | $$\Psi$$  | G         |
|-----------------------------------|----------|-----------|-----------|-----------|
| Leaps resolved                    | 77.2%    | **91.1%** | **90.0%** | 52.2%     |
| Compositions starting with tonic  | 0.9%     | **28.8%** | **28.7%** | 0.0%      |
| Compositions with unique max note | 64.7%    | 56.4%     | 59.4%     | 37.1%     |
| Compositions with unique min note | 49.4%    | 51.9%     | **58.3%** | **56.5%** |
| Notes in motif                    | 5.9%     | **75.7%** | **73.8%** | **69.3%** |
| Notes in repeated motif           | 0.007%   | **0.11%** | **0.09%** | **0.01%** |

| ![](/assets/rl_rnn/rewards_note_rnn.png)  | ![](/assets/rl_rnn/rewards_music_theory.png) | 
|:---:|:---:|
| Note RNN rewards | Music theory rewards |

| ![](/assets/rl_rnn/note_rnn.png)  | ![](/assets/rl_rnn/q.png) | ![](/assets/rl_rnn/psi.png) | ![](/assets/rl_rnn/g.png) |
|:---:|:---:|:---:|:---:|
| Note RNN | Q | $$\Psi$$ | G |

How to use the code
-------------------


Acknowledgements
----------------
This work was done in collaboration with Shane Gu, Richard E. Turner, and [Douglas Eck][doug]. Many thanks also go to my wonderful collaborators on the [Magenta][magenta] team in [Google Brain][brain], and in particular [Kyle Kastner][kastner] for his knowledgeable insights and handy spectrogram-movie-producing code. 

<!-- Our stuff (may need to change) -->
[our arxiv]: https://arxiv.org/abs/comingsoon
[code]: https://github.com/tensorflow/magenta/tree/master/magenta/models/rl-tuner

<!-- Research papers -->
[graves]: https://arxiv.org/pdf/1308.0850.pdf
[g learning]: https://arxiv.org/pdf/1512.08562.pdf
[psi learning]: http://homepages.inf.ed.ac.uk/svijayak/publications/rawlik-RSS2012.pdf
[dqn]: https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf
[dqqn]: http://www.aaai.org/Conferences/AAAI/2016/Papers/12vanHasselt12389.pdf
[gauldin]: http://www.jstor.org/stable/40213921?seq=1#page_scan_tab_contents
[livingstone]: https://secureweb.mcgill.ca/spl/files/spl/livingstoneemotion2012.pdf

<!-- External links -->
[elliot song]: https://cdn2.vox-cdn.com/uploads/chorus_asset/file/6577761/Google_-_Magenta_music_sample.0.mp3
[elliot post]: https://magenta.tensorflow.org/2016/07/15/lookback-rnn-attention-rnn/
[nips rl]: https://sites.google.com/site/deeprlnips2016/
[doug]: http://research.google.com/pubs/author39086.html
[kastner]: http://kastnerkyle.github.io/
[brain]: http://research.google.com/teams/brain/
[tensorflow]: https://www.tensorflow.org/
[magenta]: https://magenta.tensorflow.org/


<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

