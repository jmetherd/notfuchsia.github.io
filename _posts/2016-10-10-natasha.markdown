---
layout: post
title: Tuning Recurrent Neural Networks with Reinforcement Learning
date:   2016-10-24 08:00:00 -0700
author: natashajaques
tags: magenta,melody,rnn,lstm,reinforcement,music
excerpt_separator: <!--more-->
---

When I joined [Magenta][magenta] as an intern this summer, the team was hard at work on developing better ways to train Recurrent Neural Networks (RNNs) to generate sequences of notes. As you may remember from [previous posts][elliot post], these models typically consist of a Long Short-Term Memory (LSTM) network trained on monophonic melodies. This means that melodies are fed into the network one note at a time, and it is trained to predict the next note in the sequence. The figure below shows a simplified version of this type of network unrolled over time, in which it is being trained on the first 6 notes of "Twinkle Twinkle Little Star". From now on, I'll refer to this type of model as a **Note RNN**.

<div style="text-align:center"><img src="/assets/rl_rnn/note_rnn_model.png" width="256"></div>

<!--With a little hard work and creativity, a *Note RNN* can produce [nice melodies][elliot song].--> A *Note RNN* is conceptually similar to a *Character RNN*, a popular model for generating text, one character at a time. While both types of models can produce impressive results, they have some frustrating limitations. They both suffer from common failure modes, such as continually repeating the same token. Further, the sequences produced by the models tend to lack a consistent global structure. To see this more clearly, take a look at the text below, which was generated by a Character RNN trained on Wikipedia markdown data (taken from [Graves, 2013][graves]):

>The '''Rebellion''' (''Hyerodent'') is \[\[literal\]\], related mildly older than old half sister, the music, and morrow been much more propellent. All those of \[\[Hamas (mass)&#124;sausage trafficking\]\]s were also known as \[\[Trip class submarine&#124;"Sante" at Serassim\]\]; "Verra" as 1865-682-831 is related to ballistic missiles. While she viewed it friend of Halla equatorial weapons of Tuscany, in [[France]], from vaccine homes to &quot;individual&quot;, among \[\[slavery&#124;slaves\]\](such as artistual selling of factories were renamed English habit of twelve years.) 

While the model has learned how to correctly spell English words, some markdown syntax, and even mostly correct grammatical structure, sentences don't seem to follow a consistent thought. The text wonders rapidly from topic to topic, discussing everything from sisters to submarines to Tuscany, slavery, and factories, all in one short paragraph. This type of global incoherence is typical of the melodies produced by a vanilla *Note RNN* as well. They do not maintain a consistent musical structure, and can sound wandering and random. 

Music is an interesting test-bed for sequence generation, in that musical compositions adhere to a relatively well-defined set of structural rules. Any beginning music student learns that groups of notes belong to keys, chords follow progressions, and songs have consistent structures made up of musical phrases. So what if we could teach a *Note RNN* these kinds of musical rules, while still allowing it to learn patterns from music it hears in the world? 

This is the idea behind the **RL Tuner** model I will describe in this post. We take a trained *Note RNN* and teach it concepts of music theory using Reinforcement Learning (RL). RL can allow a network to learn some non-differentiable *reward* function. In this case, we define a set of music theory rules, and produce rewards based on whether the model's compositions adhere to those rules. However, to ensure that the model can remember the note probabilities it originally learned from data, we keep a second, fixed copy of the *Note RNN* which we call the *Reward RNN*. The *Reward RNN* is used to compute $$p(a$$&#124;$$s)$$, the probability of playing the next note as learned by the original *Note RNN*. We augment our music theory rewards with $$p(a$$&#124;$$s)$$, so that the total reward reflects both our music theory constraints and information learned from data.

We show that this approach allows the model to maintain high $$\log p(a$$&#124;$$s)$$ values, while significantly improving the behaviors of the *Note RNN* targeted by the music theory rewards. For example, before training with RL, 63.3% of notes produced by the *Note RNN* belonged to some excessively repeated segment of notes; after RL, 0.0-0.03% of notes were excessively repeated. Since excessively repeating tokens is a problem in other domains as well (e.g. text generation), we believe our approach could have broader applications. But does it actually work to produce better music? We conducted a user study and found that people find the compositions produced by our three RL models significantly more musically pleasing than those of the original *Note RNN*. But we encourage you to judge for yourself; samples from each of the models will be provided later in this post.

The models, derivations, and results are all described in our recent [research paper][our arxiv], written by myself, Shane Gu, Richard E. Turner, and Douglas Eck<sup>[1](#footnote-nipsrl)</sup>. [Code][code] to run this model is also available on the Magenta github repo; please try it out! The music theory rules implemented for the model are only a first attempt, and could easily be improved by someone with musical training.

<a name="footnote-nipsrl"><sub><sup>1</sup></sub></a> <sub><sup>A version of this work was accepted at the [NIPS 2016 Deep Reinforcement Learning Workshop][nips rl].</sup></sub> 

Introduction to Reinforcement Learning and Deep Q-Learning
----------------------------------------------------------
*This section will give a brief introduction to some ideas behind RL and Deep Q Networks (DQNs). Those of you familiar with these topics may wish to skip ahead.*

In reinforcement learning (RL), an agent interacts with an environment. Given the state of the enviornment $$s$$, the agent takes an action $$a$$, receives a reward $$r$$, and the environment transitions to a new state, $$s'$$. The goal of the agent is to maximize reward, which is usually some clear signal from the environment, such as points in a game. 

The rules for how the agent chooses to act in the environment define a *policy*. To learn the most effective policy, the agent can't just greedily maximize the reward it will receive after the next action, but must instead consider the total cumulative reward it can expect to receive over a course of actions occurring in the future. Because future rewards are typically uncertain if the environment has random effects, a discount factor of $$\gamma$$ is applied to the reward for each timestep in the future. If $$r_t$$ is the reward received at timestep $$t$$, then $$R_t$$ is the total future discounted *return*:
\begin{align}
R_t = \sum^T_{t'=t}\gamma^{t'-t}r_{t'} 
\end{align}

In Q-learning, the goal is to learn a Q function that gives the maximum expected discounted future return for taking any action $$a$$ in state $$s$$, and continuing to act optimally at each step in the future. Therefore the optimal Q function, $$Q^*$$ is defined as:

$$\begin{align}
Q^*(s, a) = max_\pi \mathbb{E}[R_t|s_t = s, a_t = a, \pi]
\end{align}$$

where $$\pi$$ is a policy mapping states to distributions over actions. To learn $$Q*$$, we can apply an iterative update based on the Bellman equation:
\begin{align}
Q_{i+1}(s, a) = \mathbb{E}[r + \gamma max_{a'}Q_i(s',a')|s,a]
\end{align}
where *r* is the reward received for taking action *a* in state *s*. This value iteration method will converge to $$Q^*$$ as $$i \rightarrow \infty$$ \cite{sutton}.

In [Deep Q Learning][dqn], a neural network called the Deep Q-network (DQN) is used to approximate the Q function, $$Q(s, a; \theta) \approx Q^*(s, a)$$. The network parameters $$\theta$$ are learned by applying stochastic gradient descent (SGD) updates with respect to the following loss function:
\begin{align} 
\label{eq:qloss}
L_t(\theta_t) = (Q(s,a;\theta_t) - (r_t + \gamma \max_{a'}Q(s',a';\theta_{t-1}))^2
\end{align}
The loss function describes the difference between the expected future discounted return output by the *Q-network* at step $$t$$, and the actual reward received at step $$t$$ ($$r_t$$) plus the discounted future return estimated by the *Q-network* parameters at step $$t-1$$; essentially, the prediction error in estimating the Q function. Importantly, the parameters for the previous generation of the network ($$\theta_{t-1}$$) are held fixed, and not updated by SGD.

<!--While interacting with the environment, the $$Q$$-learning agent typically follows an $$\epsilon$$-greedy policy. This means that it will greedily choose the action with the highest Q value with probability $$1-\epsilon$$, and choose a random action with probability $$\epsilon$$. This off-policy learning method ensures a reasonably trade-off between exploration of the action space, and exploitation of the most efficient strategies learned so far. -->

Several techniques are required for a DQN to work effectively. As the agent interacts with the environment, $$<s_t,a_t,r_t,s_{t+1}>$$ tuples it experiences are stored in an *experience buffer*. Training the *Q-network* is accomplished by randomly sampling batches from the *experience buffer* to compute the loss. The *experience buffer* is essential for learning; if the agent was trained using consecutive samples of experience (as in online Q-learning), the samples would be highly correlated, updates would have high variance, and the network parameters could become stuck in a local minimum or diverge. 

Further optimizations to the DQN algorithm have been proposed that help enhance learning and ensure stability. One of these is [Deep Double Q-learning][dqqn], in which a second, *Target Q-network* is used to estimate expected future return, while the *Q-network* is used to choose the next action. Since Q-learning has been shown to learn unrealistically high action values because it estimates maximum expected return, having a second Q-network can lead to more realistic estimates and better performance.

RL Tuner
----------

![Model diagram](/assets/rl_rnn/rl_rnn_diagram.png "Model diagram")

The total reward given at time $$t$$ is therefore: 

$$\begin{align} 
\label{eq:reward}
r(s,a) = \log p(a|s) + \frac{1}{c}r_{MT}(a,s)
\end{align}$$

where $$c$$ is a constant controlling the emphasis placed on the music theory reward. Given the DQN loss function in Eq. ? and modified reward function in Eq. ?, the new loss function and learned policy for our model are,

$$\begin{align}
\label{eq:melody_dqn_loss}
&L(\theta)= \mathbb{E}_\beta[(\log p(a|s) + \frac{1}{c}r_{MT}(a,s) + \gamma \max_{a'}Q(s',a';\theta^-) - Q(s,a;\theta))^2]\\
\end{align}$$

Thus, the modified loss function
forces the model to learn that the most valuable actions in terms of expected future rewards are those that conform to the music theory rules, but still have the high probability in the original data.


Music Theory Rewards
--------------------

* **Stay in key**: Notes should belong to the same key. For example, if the desired key is C-major, a B-flat would not be an acceptable note. 

* **Begin and end with the tonic note**: The first note of the composition, and the first note of the final bar should be the tonic note of the key; e.g. if the key is C-major, this note would be middle C, or 14 in our encoding. 

* **Avoid excessively repeated notes**: Unless a rest is introduced or a note is held, a single tone should not be repeated more than four times in a row. While the number four can be considered a rough heuristic, avoiding excessively repeated notes and static melodic contours is Gauldin's first rule of melodic composition \cite{gauldin1995practical}.

* **Prefer harmonious intervals**: The composition should avoid awkward intervals like augmented sevenths, or large jumps of more than an octave. Since "a mixture of motion by both step and leap is preferred, with some tendency towards the former", both small steps and larger harmonic intervals are rewarded, but the reward for smaller steps is somewhat higher. 

*  **Resolve large leaps**: When the composition leaps several pitches in one direction, it should eventually be resolved by a leap back or gradual movement in the opposite direction. Leaping twice in the same direction is negatively rewarded. 

*  **Avoid continuously repeating extrema notes**: The highest note of the composition should be unique, as should the lowest note. 

*  **Avoid high auto-correlation**: To encourage variety, the reward function penalizes a melody if it is highly correlated with itself at a lag of 1, 2, or 3 beats. 

*  **Play motifs**: A musical motif is a succession of notes representing the shortest musical "idea"; in our implementation, it is defined as a bar of music with three or more unique notes. 

*  **Play repeated motifs**: Because repetition has been shown to be key to emotional engagement with music \cite{livingstone}, we sought to train the model to repeat motifs that it had previously introduced. 


Results
----------

| Undesirable behavior              | Note RNN | Q         | $$\Psi$$  | G         |
|-----------------------------------|----------|-----------|-----------|-----------|
| Notes excessively repeated        | 63.3%    | **0.0%**  | **0.02%** | **0.03%** |
| Notes not in key                  | 0.1%     | 1.0%      | 0.6%      | 28.7%     |
| Mean autocorrelation - lag 1      | -.16     | **-.11**  | **-.10**  | .55       |
| Mean autocorrelation - lag 2      | .14      | **.03**   | **-.01**  | .31       |
| Mean autocorrelation - lag 3      | -.13     | **.03**   | **.01**   | 17        |

| Desirable behavior                | Note RNN | Q         | $$\Psi$$  | G         |
|-----------------------------------|----------|-----------|-----------|-----------|
| Leaps resolved                    | 77.2%    | **91.1%** | **90.0%** | 52.2%     |
| Compositions starting with tonic  | 0.9%     | **28.8%** | **28.7%** | 0.0%      |
| Compositions with unique max note | 64.7%    | 56.4%     | 59.4%     | 37.1%     |
| Compositions with unique min note | 49.4%    | 51.9%     | **58.3%** | **56.5%** |
| Notes in motif                    | 5.9%     | **75.7%** | **73.8%** | **69.3%** |
| Notes in repeated motif           | 0.007%   | **0.11%** | **0.09%** | **0.01%** |

| ![](/assets/rl_rnn/rewards_note_rnn.png)  | ![](/assets/rl_rnn/rewards_music_theory.png) | 
|:---:|:---:|
| Note RNN rewards | Music theory rewards |

| ![](/assets/rl_rnn/note_rnn.png)  | ![](/assets/rl_rnn/q.png) | ![](/assets/rl_rnn/psi.png) | ![](/assets/rl_rnn/g.png) |
|:---:|:---:|:---:|:---:|
| Note RNN | Q | $$\Psi$$ | G |

How to use the code
-------------------


Acknowledgements
----------------
This work was done in collaboration with Shane Gu, Richard E. Turner, and [Douglas Eck][doug]. Many thanks also go to my wonderful collaborators on the [Magenta][magenta] team in [Google Brain][brain], and in particular [Kyle Kastner][kastner] for his knowledgeable insights and handy spectrogram-movie-producing code. 

<!-- Our stuff (may need to change) -->
[our arxiv]: https://arxiv.org/abs/comingsoon
[code]: https://github.com/tensorflow/magenta/tree/master/magenta/models/rl-tuner

<!-- Research papers -->
[graves]: https://arxiv.org/pdf/1308.0850.pdf
[g learning]: https://arxiv.org/pdf/1512.08562.pdf
[psi learning]: http://homepages.inf.ed.ac.uk/svijayak/publications/rawlik-RSS2012.pdf
[dqn]: https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf
[dqqn]: http://www.aaai.org/Conferences/AAAI/2016/Papers/12vanHasselt12389.pdf

<!-- External links -->
[elliot song]: https://cdn2.vox-cdn.com/uploads/chorus_asset/file/6577761/Google_-_Magenta_music_sample.0.mp3
[elliot post]: https://magenta.tensorflow.org/2016/07/15/lookback-rnn-attention-rnn/
[nips rl]: https://sites.google.com/site/deeprlnips2016/
[doug]: http://research.google.com/pubs/author39086.html
[kastner]: http://kastnerkyle.github.io/
[brain]: http://research.google.com/teams/brain/
[tensorflow]: https://www.tensorflow.org/
[magenta]: https://magenta.tensorflow.org/


<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

